<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIB: mlib::Query Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mlib</b></li><li class="navelem"><a class="el" href="classmlib_1_1_query.html">Query</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlib_1_1_query-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlib::Query Class Reference<div class="ingroups"><a class="el" href="group__sqlite.html">SQLite C++ Wrappers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Wrapper for SQL prepared sentences.  
 <a href="classmlib_1_1_query.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sqlitepp_8h_source.html">sqlitepp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7ee97cc5ed429ef7a420c4549e9fd6f0"><td class="memItemLeft" align="right" valign="top"><a id="a7ee97cc5ed429ef7a420c4549e9fd6f0" name="a7ee97cc5ed429ef7a420c4549e9fd6f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Query</b> ()</td></tr>
<tr class="memdesc:a7ee97cc5ed429ef7a420c4549e9fd6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a7ee97cc5ed429ef7a420c4549e9fd6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf4ddcb778885223d11bc35030e5b1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#abbf4ddcb778885223d11bc35030e5b1c">Query</a> (<a class="el" href="classmlib_1_1_database.html">Database</a> &amp;db)</td></tr>
<tr class="memdesc:abbf4ddcb778885223d11bc35030e5b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statement attached to a database but without any SQL.  <a href="classmlib_1_1_query.html#abbf4ddcb778885223d11bc35030e5b1c">More...</a><br /></td></tr>
<tr class="separator:abbf4ddcb778885223d11bc35030e5b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ac3f9772f421243172e9cd43574af8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#ae0ac3f9772f421243172e9cd43574af8">Query</a> (<a class="el" href="classmlib_1_1_database.html">Database</a> &amp;db, const std::string &amp;<a class="el" href="classmlib_1_1_query.html#aec30b70916c6ccb20e730f791e4fa025">sql</a>)</td></tr>
<tr class="memdesc:ae0ac3f9772f421243172e9cd43574af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a prepared statement from SQL text.  <a href="classmlib_1_1_query.html#ae0ac3f9772f421243172e9cd43574af8">More...</a><br /></td></tr>
<tr class="separator:ae0ac3f9772f421243172e9cd43574af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff62afaf55d15df6667d76c63c17592"><td class="memItemLeft" align="right" valign="top"><a id="a3ff62afaf55d15df6667d76c63c17592" name="a3ff62afaf55d15df6667d76c63c17592"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Query</b> (<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a3ff62afaf55d15df6667d76c63c17592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a3ff62afaf55d15df6667d76c63c17592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5667d85697968b5a9a08897da414d3"><td class="memItemLeft" align="right" valign="top"><a id="a9b5667d85697968b5a9a08897da414d3" name="a9b5667d85697968b5a9a08897da414d3"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&amp;rhs)</td></tr>
<tr class="memdesc:a9b5667d85697968b5a9a08897da414d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a9b5667d85697968b5a9a08897da414d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd2d130c12ab93c9e3acb9051bac0c6"><td class="memItemLeft" align="right" valign="top"><a id="a7bd2d130c12ab93c9e3acb9051bac0c6" name="a7bd2d130c12ab93c9e3acb9051bac0c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator sqlite3_stmt *</b> ()</td></tr>
<tr class="memdesc:a7bd2d130c12ab93c9e3acb9051bac0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the underlining statement handle. <br /></td></tr>
<tr class="separator:a7bd2d130c12ab93c9e3acb9051bac0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4ff3a27365317354c69b9fae0b6ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#acb4ff3a27365317354c69b9fae0b6ea0">operator=</a> (const std::string &amp;<a class="el" href="classmlib_1_1_query.html#aec30b70916c6ccb20e730f791e4fa025">sql</a>)</td></tr>
<tr class="memdesc:acb4ff3a27365317354c69b9fae0b6ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign SQL text to a query.  <a href="classmlib_1_1_query.html#acb4ff3a27365317354c69b9fae0b6ea0">More...</a><br /></td></tr>
<tr class="separator:acb4ff3a27365317354c69b9fae0b6ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec30b70916c6ccb20e730f791e4fa025"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#aec30b70916c6ccb20e730f791e4fa025">sql</a> () const</td></tr>
<tr class="memdesc:aec30b70916c6ccb20e730f791e4fa025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve SQL text.  <a href="classmlib_1_1_query.html#aec30b70916c6ccb20e730f791e4fa025">More...</a><br /></td></tr>
<tr class="separator:aec30b70916c6ccb20e730f791e4fa025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0be57b8bd7f466bbece68da4223d92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a3d0be57b8bd7f466bbece68da4223d92">operator std::string</a> () const</td></tr>
<tr class="memdesc:a3d0be57b8bd7f466bbece68da4223d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve SQL text.  <a href="classmlib_1_1_query.html#a3d0be57b8bd7f466bbece68da4223d92">More...</a><br /></td></tr>
<tr class="separator:a3d0be57b8bd7f466bbece68da4223d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e176db273b9a8a26583b80d9db2cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlib_1_1erc.html">erc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#ad2e176db273b9a8a26583b80d9db2cbd">step</a> ()</td></tr>
<tr class="memdesc:ad2e176db273b9a8a26583b80d9db2cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the statement.  <a href="classmlib_1_1_query.html#ad2e176db273b9a8a26583b80d9db2cbd">More...</a><br /></td></tr>
<tr class="separator:ad2e176db273b9a8a26583b80d9db2cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9304aa6f21b149696d0cc11a98ee6761"><td class="memItemLeft" align="right" valign="top"><a id="a9304aa6f21b149696d0cc11a98ee6761" name="a9304aa6f21b149696d0cc11a98ee6761"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>columns</b> ()</td></tr>
<tr class="memdesc:a9304aa6f21b149696d0cc11a98ee6761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of columns in the result set. <br /></td></tr>
<tr class="separator:a9304aa6f21b149696d0cc11a98ee6761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ab51f8bedc890e7c7580b45b6131d5"><td class="memItemLeft" align="right" valign="top"><a id="ae7ab51f8bedc890e7c7580b45b6131d5" name="ae7ab51f8bedc890e7c7580b45b6131d5"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:ae7ab51f8bedc890e7c7580b45b6131d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset statement to initial state. <br /></td></tr>
<tr class="separator:ae7ab51f8bedc890e7c7580b45b6131d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d762cc2f632327002226ab537e8b7f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a9d762cc2f632327002226ab537e8b7f2">finalize</a> ()</td></tr>
<tr class="memdesc:a9d762cc2f632327002226ab537e8b7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statements are automatically finalized when <a class="el" href="classmlib_1_1_query.html" title="Wrapper for SQL prepared sentences.">Query</a> objects are destructed or assigned a new SQL text.  <a href="classmlib_1_1_query.html#a9d762cc2f632327002226ab537e8b7f2">More...</a><br /></td></tr>
<tr class="separator:a9d762cc2f632327002226ab537e8b7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bind functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p >SQL statement can have parameters specified by number (<code>?</code> or <code>?nnn</code>) or by name (<code>:aaa</code> or <code>@aaa</code> or <code>$aaa</code>) where <code>nnn</code> is a number (starting from 1) and <code>aaa</code> is an alphanumeric identifier.</p>
<p >Bind functions assign values to these parameters.</p>
<p >If the parameter with that name or number is not found the functions throw an <a class="el" href="classmlib_1_1erc.html">erc</a> with code <code>SQLITE_RANGE</code>. </p>
</div></td></tr>
<tr class="memitem:afbe9e5903682a7427ea6b928f35a2d1b"><td class="memItemLeft" align="right" valign="top"><a id="afbe9e5903682a7427ea6b928f35a2d1b" name="afbe9e5903682a7427ea6b928f35a2d1b"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (int par, const std::string &amp;val)</td></tr>
<tr class="memdesc:afbe9e5903682a7427ea6b928f35a2d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by number to a character string. <br /></td></tr>
<tr class="separator:afbe9e5903682a7427ea6b928f35a2d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5146404b97ec07bfb249619a40af09ee"><td class="memItemLeft" align="right" valign="top"><a id="a5146404b97ec07bfb249619a40af09ee" name="a5146404b97ec07bfb249619a40af09ee"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (const std::string &amp;parname, const std::string &amp;val)</td></tr>
<tr class="memdesc:a5146404b97ec07bfb249619a40af09ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by name to a character string. <br /></td></tr>
<tr class="separator:a5146404b97ec07bfb249619a40af09ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4ca187d267a0a3f287a0499eb5b3f6"><td class="memItemLeft" align="right" valign="top"><a id="a1c4ca187d267a0a3f287a0499eb5b3f6" name="a1c4ca187d267a0a3f287a0499eb5b3f6"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (int par, int val)</td></tr>
<tr class="memdesc:a1c4ca187d267a0a3f287a0499eb5b3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by number to an integer value. <br /></td></tr>
<tr class="separator:a1c4ca187d267a0a3f287a0499eb5b3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8467caf56d7a55d81fcc4f5aa98a5e"><td class="memItemLeft" align="right" valign="top"><a id="ace8467caf56d7a55d81fcc4f5aa98a5e" name="ace8467caf56d7a55d81fcc4f5aa98a5e"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (const std::string &amp;parname, int val)</td></tr>
<tr class="memdesc:ace8467caf56d7a55d81fcc4f5aa98a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by name to an integer value. <br /></td></tr>
<tr class="separator:ace8467caf56d7a55d81fcc4f5aa98a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fce6f00cd7f7cd7cf9fbc8298d7473"><td class="memItemLeft" align="right" valign="top"><a id="aa0fce6f00cd7f7cd7cf9fbc8298d7473" name="aa0fce6f00cd7f7cd7cf9fbc8298d7473"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (int par, double val)</td></tr>
<tr class="memdesc:aa0fce6f00cd7f7cd7cf9fbc8298d7473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by number to a floating point value. <br /></td></tr>
<tr class="separator:aa0fce6f00cd7f7cd7cf9fbc8298d7473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa91c4df7b4639469c8ec555e6bd3b70"><td class="memItemLeft" align="right" valign="top"><a id="afa91c4df7b4639469c8ec555e6bd3b70" name="afa91c4df7b4639469c8ec555e6bd3b70"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (const std::string &amp;parname, double val)</td></tr>
<tr class="memdesc:afa91c4df7b4639469c8ec555e6bd3b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by name to a floating point value. <br /></td></tr>
<tr class="separator:afa91c4df7b4639469c8ec555e6bd3b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5718b6b188efe29c0de6310409647894"><td class="memItemLeft" align="right" valign="top"><a id="a5718b6b188efe29c0de6310409647894" name="a5718b6b188efe29c0de6310409647894"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (int par, __int64 val)</td></tr>
<tr class="memdesc:a5718b6b188efe29c0de6310409647894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by number to a large integer. <br /></td></tr>
<tr class="separator:a5718b6b188efe29c0de6310409647894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275ab206b278903d58ac6aa7797b8409"><td class="memItemLeft" align="right" valign="top"><a id="a275ab206b278903d58ac6aa7797b8409" name="a275ab206b278903d58ac6aa7797b8409"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>bind</b> (const std::string &amp;parname, __int64 val)</td></tr>
<tr class="memdesc:a275ab206b278903d58ac6aa7797b8409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by name to a large integer. <br /></td></tr>
<tr class="separator:a275ab206b278903d58ac6aa7797b8409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a2815e174e058eb895ce600cd35cb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a80a2815e174e058eb895ce600cd35cb5">bind</a> (int par, void *val, int len)</td></tr>
<tr class="memdesc:a80a2815e174e058eb895ce600cd35cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by number to an arbitrary memory area (BLOB)  <a href="classmlib_1_1_query.html#a80a2815e174e058eb895ce600cd35cb5">More...</a><br /></td></tr>
<tr class="separator:a80a2815e174e058eb895ce600cd35cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5f4cdfdfdcff5f577dcd79b3d109d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a1a5f4cdfdfdcff5f577dcd79b3d109d7">bind</a> (const std::string &amp;parname, void *val, int len)</td></tr>
<tr class="memdesc:a1a5f4cdfdfdcff5f577dcd79b3d109d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by name to an arbitrary memory area (BLOB)  <a href="classmlib_1_1_query.html#a1a5f4cdfdfdcff5f577dcd79b3d109d7">More...</a><br /></td></tr>
<tr class="separator:a1a5f4cdfdfdcff5f577dcd79b3d109d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4727e9519278f619eb272ec70c38e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#ab4727e9519278f619eb272ec70c38e77">bind</a> (int par, const SYSTEMTIME &amp;st)</td></tr>
<tr class="memdesc:ab4727e9519278f619eb272ec70c38e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by number to a <code>SYSTEMTIME</code> value.  <a href="classmlib_1_1_query.html#ab4727e9519278f619eb272ec70c38e77">More...</a><br /></td></tr>
<tr class="separator:ab4727e9519278f619eb272ec70c38e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e016e1040b4a540918d3c9796e6f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#ad3e016e1040b4a540918d3c9796e6f5d">bind</a> (const std::string &amp;parname, const SYSTEMTIME &amp;st)</td></tr>
<tr class="memdesc:ad3e016e1040b4a540918d3c9796e6f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parameter specified by name to a <code>SYSTEMTIME</code> value.  <a href="classmlib_1_1_query.html#ad3e016e1040b4a540918d3c9796e6f5d">More...</a><br /></td></tr>
<tr class="separator:ad3e016e1040b4a540918d3c9796e6f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4ff83cf47c9614be9222ea8c26dea2"><td class="memItemLeft" align="right" valign="top"><a id="a3d4ff83cf47c9614be9222ea8c26dea2" name="a3d4ff83cf47c9614be9222ea8c26dea2"></a>
<a class="el" href="classmlib_1_1_query.html">Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>clear_bindings</b> ()</td></tr>
<tr class="memdesc:a3d4ff83cf47c9614be9222ea8c26dea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all parameters to NULL values. <br /></td></tr>
<tr class="separator:a3d4ff83cf47c9614be9222ea8c26dea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data retrieval functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p ><code>columm_...</code> functions retrieve data from a column specified by name or number (starting from 0).</p>
<p >Data type of the result is determined by the result function called (<code>column_int</code> returns an integer, <code>column_double</code> returns a double, and so on).</p>
<p >Note that column name <em>does not</em> include table name. If you need to disambiguate column names, use an <code>AS</code> clause in the <code>SELECT</code> statement.</p>
<p >If a column with that name cannot be found, the functions throw an <a class="el" href="classmlib_1_1erc.html">erc</a> with code <code>SQLITE_RANGE</code>.</p>
<p >For a detailed discussion of the conversions applied see <a href="http://sqlite.org/c3ref/column_blob.html">SQLITE documentation</a> </p>
</div></td></tr>
<tr class="memitem:a14a042e12cd4f873a1604710831a7165"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a14a042e12cd4f873a1604710831a7165">column_int</a> (int nc) const</td></tr>
<tr class="memdesc:a14a042e12cd4f873a1604710831a7165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column value converted to an integer.  <a href="classmlib_1_1_query.html#a14a042e12cd4f873a1604710831a7165">More...</a><br /></td></tr>
<tr class="separator:a14a042e12cd4f873a1604710831a7165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ff611d36df4fbe549113e60970746a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a04ff611d36df4fbe549113e60970746a">column_int</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:a04ff611d36df4fbe549113e60970746a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column value converted to an integer.   <a href="classmlib_1_1_query.html#a04ff611d36df4fbe549113e60970746a">More...</a><br /></td></tr>
<tr class="separator:a04ff611d36df4fbe549113e60970746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f70733482df265f72e270ddcd69929"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a43f70733482df265f72e270ddcd69929">column_str</a> (int nc) const</td></tr>
<tr class="memdesc:a43f70733482df265f72e270ddcd69929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column value as an UTF-8 encoded string.  <a href="classmlib_1_1_query.html#a43f70733482df265f72e270ddcd69929">More...</a><br /></td></tr>
<tr class="separator:a43f70733482df265f72e270ddcd69929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033f4f9b638a36cea5f15a720f467763"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a033f4f9b638a36cea5f15a720f467763">column_str</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:a033f4f9b638a36cea5f15a720f467763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column value as an UTF-8 encoded string.   <a href="classmlib_1_1_query.html#a033f4f9b638a36cea5f15a720f467763">More...</a><br /></td></tr>
<tr class="separator:a033f4f9b638a36cea5f15a720f467763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc1fbb9738f77c5e774ad2258d401c8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a6dc1fbb9738f77c5e774ad2258d401c8">column_text</a> (int nc) const</td></tr>
<tr class="memdesc:a6dc1fbb9738f77c5e774ad2258d401c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a NULL-terminated text with the column content.  <a href="classmlib_1_1_query.html#a6dc1fbb9738f77c5e774ad2258d401c8">More...</a><br /></td></tr>
<tr class="separator:a6dc1fbb9738f77c5e774ad2258d401c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aab724208a7f837a6dd58f6ff397319"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a0aab724208a7f837a6dd58f6ff397319">column_text</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:a0aab724208a7f837a6dd58f6ff397319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a NULL-terminated text with the column content.   <a href="classmlib_1_1_query.html#a0aab724208a7f837a6dd58f6ff397319">More...</a><br /></td></tr>
<tr class="separator:a0aab724208a7f837a6dd58f6ff397319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2af35a6180c5c24816c147b38094705"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#ac2af35a6180c5c24816c147b38094705">column_double</a> (int nc) const</td></tr>
<tr class="memdesc:ac2af35a6180c5c24816c147b38094705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return floating point value of the column.  <a href="classmlib_1_1_query.html#ac2af35a6180c5c24816c147b38094705">More...</a><br /></td></tr>
<tr class="separator:ac2af35a6180c5c24816c147b38094705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eca6bcdc9300a70b3c6cd95ccf4682"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a10eca6bcdc9300a70b3c6cd95ccf4682">column_double</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:a10eca6bcdc9300a70b3c6cd95ccf4682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return floating point value of the column.   <a href="classmlib_1_1_query.html#a10eca6bcdc9300a70b3c6cd95ccf4682">More...</a><br /></td></tr>
<tr class="separator:a10eca6bcdc9300a70b3c6cd95ccf4682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85866535302815c2357b470fbdf6f632"><td class="memItemLeft" align="right" valign="top">__int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a85866535302815c2357b470fbdf6f632">column_int64</a> (int nc) const</td></tr>
<tr class="memdesc:a85866535302815c2357b470fbdf6f632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column value converted to a 64-bit integer.  <a href="classmlib_1_1_query.html#a85866535302815c2357b470fbdf6f632">More...</a><br /></td></tr>
<tr class="separator:a85866535302815c2357b470fbdf6f632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace10b184f6c5652000f951a57c85bc33"><td class="memItemLeft" align="right" valign="top">__int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#ace10b184f6c5652000f951a57c85bc33">column_int64</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ace10b184f6c5652000f951a57c85bc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column value converted to a 64-bit integer.   <a href="classmlib_1_1_query.html#ace10b184f6c5652000f951a57c85bc33">More...</a><br /></td></tr>
<tr class="separator:ace10b184f6c5652000f951a57c85bc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6958e42529d05538f8d272592c16555"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#aa6958e42529d05538f8d272592c16555">column_blob</a> (int nc) const</td></tr>
<tr class="memdesc:aa6958e42529d05538f8d272592c16555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a BLOB with the column content.  <a href="classmlib_1_1_query.html#aa6958e42529d05538f8d272592c16555">More...</a><br /></td></tr>
<tr class="separator:aa6958e42529d05538f8d272592c16555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0ed9a2eb4726cdfecf0e32960b479c"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a8d0ed9a2eb4726cdfecf0e32960b479c">column_blob</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a8d0ed9a2eb4726cdfecf0e32960b479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a BLOB with the column content.  (int) const  <a href="classmlib_1_1_query.html#a8d0ed9a2eb4726cdfecf0e32960b479c">More...</a><br /></td></tr>
<tr class="separator:a8d0ed9a2eb4726cdfecf0e32960b479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905a65c02709333ba359ab004fa2d245"><td class="memItemLeft" align="right" valign="top"><a id="a905a65c02709333ba359ab004fa2d245" name="a905a65c02709333ba359ab004fa2d245"></a>
SYSTEMTIME&#160;</td><td class="memItemRight" valign="bottom"><b>column_time</b> (int nc) const</td></tr>
<tr class="memdesc:a905a65c02709333ba359ab004fa2d245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a SYSTEMTIME structure with the column content. <br /></td></tr>
<tr class="separator:a905a65c02709333ba359ab004fa2d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea41e784736c198bb10f1c37bc9db5"><td class="memItemLeft" align="right" valign="top">SYSTEMTIME&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a78ea41e784736c198bb10f1c37bc9db5">column_time</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a78ea41e784736c198bb10f1c37bc9db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a SYSTEMTIME structure with the column content.   <a href="classmlib_1_1_query.html#a78ea41e784736c198bb10f1c37bc9db5">More...</a><br /></td></tr>
<tr class="separator:a78ea41e784736c198bb10f1c37bc9db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other column functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p ><br  />
 </p>
</div></td></tr>
<tr class="memitem:a291400a7b75387cadc091b2796be9e4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a291400a7b75387cadc091b2796be9e4c">column_type</a> (int nc) const</td></tr>
<tr class="memdesc:a291400a7b75387cadc091b2796be9e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return data type for a column specified by name or number.  <a href="classmlib_1_1_query.html#a291400a7b75387cadc091b2796be9e4c">More...</a><br /></td></tr>
<tr class="separator:a291400a7b75387cadc091b2796be9e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4c7cb991e1237c042c1d2c0242efc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#aeb4c7cb991e1237c042c1d2c0242efc6">column_type</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:aeb4c7cb991e1237c042c1d2c0242efc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return data type for a column specified by name or number.   <a href="classmlib_1_1_query.html#aeb4c7cb991e1237c042c1d2c0242efc6">More...</a><br /></td></tr>
<tr class="separator:aeb4c7cb991e1237c042c1d2c0242efc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5390845f173112466fd14f71fb324ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#aa5390845f173112466fd14f71fb324ea">column_size</a> (int nc) const</td></tr>
<tr class="memdesc:aa5390845f173112466fd14f71fb324ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes in a column that contains a BLOB or a string.  <a href="classmlib_1_1_query.html#aa5390845f173112466fd14f71fb324ea">More...</a><br /></td></tr>
<tr class="separator:aa5390845f173112466fd14f71fb324ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa046d124bfc326b1581b3706c3d67873"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#aa046d124bfc326b1581b3706c3d67873">column_size</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:aa046d124bfc326b1581b3706c3d67873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of bytes in a column that contains a BLOB or a string.  (int) const  <a href="classmlib_1_1_query.html#aa046d124bfc326b1581b3706c3d67873">More...</a><br /></td></tr>
<tr class="separator:aa046d124bfc326b1581b3706c3d67873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21197415531fe00458af8806f3839dd7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a21197415531fe00458af8806f3839dd7">decl_type</a> (int nc) const</td></tr>
<tr class="separator:a21197415531fe00458af8806f3839dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299ae3af338cf9a17795c04208db0331"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a299ae3af338cf9a17795c04208db0331">decl_type</a> (const std::string &amp;colname) const</td></tr>
<tr class="separator:a299ae3af338cf9a17795c04208db0331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce027452948e77237e51a40221730e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#abce027452948e77237e51a40221730e5">table_name</a> (int nc) const</td></tr>
<tr class="memdesc:abce027452948e77237e51a40221730e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return originating table name.  <a href="classmlib_1_1_query.html#abce027452948e77237e51a40221730e5">More...</a><br /></td></tr>
<tr class="separator:abce027452948e77237e51a40221730e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aef20f35f72c99a6d0355bc2bf5dc5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#ae0aef20f35f72c99a6d0355bc2bf5dc5">table_name</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:ae0aef20f35f72c99a6d0355bc2bf5dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return originating table name.  <a href="classmlib_1_1_query.html#ae0aef20f35f72c99a6d0355bc2bf5dc5">More...</a><br /></td></tr>
<tr class="separator:ae0aef20f35f72c99a6d0355bc2bf5dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1804e036bf3cc4c5e97d8ad2e9ab341"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#af1804e036bf3cc4c5e97d8ad2e9ab341">database_name</a> (int nc) const</td></tr>
<tr class="memdesc:af1804e036bf3cc4c5e97d8ad2e9ab341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return originating schema name.  <a href="classmlib_1_1_query.html#af1804e036bf3cc4c5e97d8ad2e9ab341">More...</a><br /></td></tr>
<tr class="separator:af1804e036bf3cc4c5e97d8ad2e9ab341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dff4f8a839df1c35bcf13b15f6c764"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#af9dff4f8a839df1c35bcf13b15f6c764">database_name</a> (const std::string &amp;colname) const</td></tr>
<tr class="memdesc:af9dff4f8a839df1c35bcf13b15f6c764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return originating schema name.  <a href="classmlib_1_1_query.html#af9dff4f8a839df1c35bcf13b15f6c764">More...</a><br /></td></tr>
<tr class="separator:af9dff4f8a839df1c35bcf13b15f6c764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a47add41ef4949f007fb268b198c67d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlib_1_1_query.html#a9a47add41ef4949f007fb268b198c67d">column_name</a> (int nc) const</td></tr>
<tr class="memdesc:a9a47add41ef4949f007fb268b198c67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column name.  <a href="classmlib_1_1_query.html#a9a47add41ef4949f007fb268b198c67d">More...</a><br /></td></tr>
<tr class="separator:a9a47add41ef4949f007fb268b198c67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6efef52d7a939622bbc934ff6b90ffe0"><td class="memItemLeft" align="right" valign="top"><a id="a6efef52d7a939622bbc934ff6b90ffe0" name="a6efef52d7a939622bbc934ff6b90ffe0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Database</b></td></tr>
<tr class="separator:a6efef52d7a939622bbc934ff6b90ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Wrapper for SQL prepared sentences. </p>
<p >The <a class="el" href="classmlib_1_1_query.html" title="Wrapper for SQL prepared sentences.">Query</a> class is a wrapper around a prepared <a href="http://sqlite.org/c3ref/stmt.html">sqlite3</a> statement.</p>
<p >There are no copy constructors as the status of a prepared statement cannot be fully reproduced.</p>
<p >The class provides a number of overloaded <code>bind</code> functions that can be used to bind parameters specified either by name or by number (first parameter is 1) to values of different types.</p>
<p >All bind functions return a reference to the object allowing them to be syntactically chained as in the following example: </p><div class="fragment"><div class="line"><a class="code hl_function" href="classmlib_1_1_query.html#a7ee97cc5ed429ef7a420c4549e9fd6f0">Query</a>  (db, <span class="stringliteral">&quot;INSERT INTO table (col1, col2) VALUES (:param1, :param2);&quot;</span>)</div>
<div class="line">  .bind (<span class="stringliteral">&quot;:param1&quot;</span>, value1)</div>
<div class="line">  .bind (<span class="stringliteral">&quot;:param2&quot;</span>, value2)</div>
<div class="line">  .step ();</div>
<div class="ttc" id="aclassmlib_1_1_query_html_a7ee97cc5ed429ef7a420c4549e9fd6f0"><div class="ttname"><a href="classmlib_1_1_query.html#a7ee97cc5ed429ef7a420c4549e9fd6f0">mlib::Query::Query</a></div><div class="ttdeci">Query()</div><div class="ttdoc">Default constructor.</div><div class="ttdef"><b>Definition:</b> sqlitepp.h:254</div></div>
</div><!-- fragment --><p >For data extraction, the class provides <code>column_xxx</code> functions that return the value of a column specified either by name or by index (first column index is 0). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abbf4ddcb778885223d11bc35030e5b1c" name="abbf4ddcb778885223d11bc35030e5b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf4ddcb778885223d11bc35030e5b1c">&#9670;&#160;</a></span>Query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlib::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlib_1_1_database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statement attached to a database but without any SQL. </p>
<p >The object is linked to a database but doesn't have yet a prepared statement associated with it.</p>
<p >This is convenient for statements that will latter receive their SQL through the assignment operator. </p>

</div>
</div>
<a id="ae0ac3f9772f421243172e9cd43574af8" name="ae0ac3f9772f421243172e9cd43574af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ac3f9772f421243172e9cd43574af8">&#9670;&#160;</a></span>Query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlib::Query::Query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlib_1_1_database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a prepared statement from SQL text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>database connection </td></tr>
    <tr><td class="paramname">sql</td><td>SQL statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3e016e1040b4a540918d3c9796e6f5d" name="ad3e016e1040b4a540918d3c9796e6f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e016e1040b4a540918d3c9796e6f5d">&#9670;&#160;</a></span>bind() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp; mlib::Query::bind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SYSTEMTIME &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a parameter specified by name to a <code>SYSTEMTIME</code> value. </p>
<p >The value is written in a format compatible with SQLITE <code>strftime</code> function </p>

</div>
</div>
<a id="a1a5f4cdfdfdcff5f577dcd79b3d109d7" name="a1a5f4cdfdfdcff5f577dcd79b3d109d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5f4cdfdfdcff5f577dcd79b3d109d7">&#9670;&#160;</a></span>bind() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp; mlib::Query::bind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a parameter specified by name to an arbitrary memory area (BLOB) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parname</td><td>parameter name </td></tr>
    <tr><td class="paramname">val</td><td>pointer to BLOB </td></tr>
    <tr><td class="paramname">len</td><td>size of BLOB</td></tr>
  </table>
  </dd>
</dl>
<p>The function makes a local copy of the value so user can free it immediately. </p>

</div>
</div>
<a id="ab4727e9519278f619eb272ec70c38e77" name="ab4727e9519278f619eb272ec70c38e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4727e9519278f619eb272ec70c38e77">&#9670;&#160;</a></span>bind() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp; mlib::Query::bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SYSTEMTIME &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a parameter specified by number to a <code>SYSTEMTIME</code> value. </p>
<p >The value is written in a format compatible with SQLITE <code>strftime</code> function </p>

</div>
</div>
<a id="a80a2815e174e058eb895ce600cd35cb5" name="a80a2815e174e058eb895ce600cd35cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a2815e174e058eb895ce600cd35cb5">&#9670;&#160;</a></span>bind() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp; mlib::Query::bind </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a parameter specified by number to an arbitrary memory area (BLOB) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">par</td><td>parameter index (starting from 1) </td></tr>
    <tr><td class="paramname">val</td><td>pointer to BLOB </td></tr>
    <tr><td class="paramname">len</td><td>size of BLOB</td></tr>
  </table>
  </dd>
</dl>
<p>The function makes a local copy of the value so user can free it immediately. </p>

</div>
</div>
<a id="a8d0ed9a2eb4726cdfecf0e32960b479c" name="a8d0ed9a2eb4726cdfecf0e32960b479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0ed9a2eb4726cdfecf0e32960b479c">&#9670;&#160;</a></span>column_blob() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * mlib::Query::column_blob </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a BLOB with the column content.  (int) const </p>
<p >The memory for the BLOB is freed automatically. Call <a class="el" href="classmlib_1_1_query.html#aa5390845f173112466fd14f71fb324ea" title="Return number of bytes in a column that contains a BLOB or a string.">column_size()</a> function <b>after</b> calling this function to determine the size of the object returned.  (int) const </p>

</div>
</div>
<a id="aa6958e42529d05538f8d272592c16555" name="aa6958e42529d05538f8d272592c16555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6958e42529d05538f8d272592c16555">&#9670;&#160;</a></span>column_blob() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * mlib::Query::column_blob </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a BLOB with the column content. </p>
<p >The memory for the BLOB is freed automatically. Call <a class="el" href="classmlib_1_1_query.html#aa5390845f173112466fd14f71fb324ea" title="Return number of bytes in a column that contains a BLOB or a string.">column_size()</a> function <b>after</b> calling this function to determine the size of the object returned. </p>

</div>
</div>
<a id="a10eca6bcdc9300a70b3c6cd95ccf4682" name="a10eca6bcdc9300a70b3c6cd95ccf4682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eca6bcdc9300a70b3c6cd95ccf4682">&#9670;&#160;</a></span>column_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mlib::Query::column_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return floating point value of the column.  </p>
<p >The following rules apply:</p><ul>
<li><code>NULL</code> value is converted to 0.0</li>
<li><code>INTEGER</code> value is promoted to double</li>
<li><code>TEXT</code> or BLOB value is converted to number. Longest possible prefix of the value that can be interpreted as a real number is extracted and the remainder ignored. Any leading spaces are ignored.  </li>
</ul>

</div>
</div>
<a id="ac2af35a6180c5c24816c147b38094705" name="ac2af35a6180c5c24816c147b38094705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2af35a6180c5c24816c147b38094705">&#9670;&#160;</a></span>column_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mlib::Query::column_double </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return floating point value of the column. </p>
<p >The following rules apply:</p><ul>
<li><code>NULL</code> value is converted to 0.0</li>
<li><code>INTEGER</code> value is promoted to double</li>
<li><code>TEXT</code> or BLOB value is converted to number. Longest possible prefix of the value that can be interpreted as a real number is extracted and the remainder ignored. Any leading spaces are ignored. </li>
</ul>

</div>
</div>
<a id="a04ff611d36df4fbe549113e60970746a" name="a04ff611d36df4fbe549113e60970746a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ff611d36df4fbe549113e60970746a">&#9670;&#160;</a></span>column_int() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlib::Query::column_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return column value converted to an integer.  </p>
<p >The following rules apply:</p><ul>
<li><code>NULL</code> value is converted to 0</li>
<li><code>REAL</code> value is rounded to nearest integer</li>
<li><code>TEXT</code> or BLOB value is converted to number. Longest possible prefix of the value that can be interpreted as an integer number is extracted and the remainder ignored. Any leading spaces are ignored.  </li>
</ul>

</div>
</div>
<a id="a14a042e12cd4f873a1604710831a7165" name="a14a042e12cd4f873a1604710831a7165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a042e12cd4f873a1604710831a7165">&#9670;&#160;</a></span>column_int() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlib::Query::column_int </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return column value converted to an integer. </p>
<p >The following rules apply:</p><ul>
<li><code>NULL</code> value is converted to 0</li>
<li><code>REAL</code> value is rounded to nearest integer</li>
<li><code>TEXT</code> or BLOB value is converted to number. Longest possible prefix of the value that can be interpreted as an integer number is extracted and the remainder ignored. Any leading spaces are ignored. </li>
</ul>

</div>
</div>
<a id="ace10b184f6c5652000f951a57c85bc33" name="ace10b184f6c5652000f951a57c85bc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace10b184f6c5652000f951a57c85bc33">&#9670;&#160;</a></span>column_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__int64 mlib::Query::column_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return column value converted to a 64-bit integer.  </p>
<p >The following rules apply:</p><ul>
<li><code>NULL</code> value is converted to 0</li>
<li><code>REAL</code> value is rounded to nearest integer</li>
<li><code>TEXT</code> or <code>BLOB</code> value is converted to number. Longest possible prefix of the value that can be interpreted as an integer number is extracted and the remainder ignored. Any leading spaces are ignored.  </li>
</ul>

</div>
</div>
<a id="a85866535302815c2357b470fbdf6f632" name="a85866535302815c2357b470fbdf6f632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85866535302815c2357b470fbdf6f632">&#9670;&#160;</a></span>column_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__int64 mlib::Query::column_int64 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return column value converted to a 64-bit integer. </p>
<p >The following rules apply:</p><ul>
<li><code>NULL</code> value is converted to 0</li>
<li><code>REAL</code> value is rounded to nearest integer</li>
<li><code>TEXT</code> or <code>BLOB</code> value is converted to number. Longest possible prefix of the value that can be interpreted as an integer number is extracted and the remainder ignored. Any leading spaces are ignored. </li>
</ul>

</div>
</div>
<a id="a9a47add41ef4949f007fb268b198c67d" name="a9a47add41ef4949f007fb268b198c67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a47add41ef4949f007fb268b198c67d">&#9670;&#160;</a></span>column_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::column_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return column name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nc</td><td>- column number</td></tr>
  </table>
  </dd>
</dl>
<p>If the query is a SELECT statement and <code>nc</code> is a valid column number, the function returns the name of the column. Otherwise the function returns an empty string. The name of a result column is the value of the <code>AS</code> clause for that column, if there is an <code>AS</code> clause. If there is no <code>AS</code> clause then the name of the column is unspecified and may change from one release of SQLite to the next.</p>
<p >The returned string is always UTF-8 encoded. </p>

</div>
</div>
<a id="aa046d124bfc326b1581b3706c3d67873" name="aa046d124bfc326b1581b3706c3d67873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa046d124bfc326b1581b3706c3d67873">&#9670;&#160;</a></span>column_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlib::Query::column_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of bytes in a column that contains a BLOB or a string.  (int) const </p>
<p >If the result is NULL the function returns 0. For a numerical column, the function returns the size of the string representation of the value.  (int) const </p>

</div>
</div>
<a id="aa5390845f173112466fd14f71fb324ea" name="aa5390845f173112466fd14f71fb324ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5390845f173112466fd14f71fb324ea">&#9670;&#160;</a></span>column_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlib::Query::column_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of bytes in a column that contains a BLOB or a string. </p>
<p >If the result is NULL the function returns 0. For a numerical column, the function returns the size of the string representation of the value. </p>

</div>
</div>
<a id="a033f4f9b638a36cea5f15a720f467763" name="a033f4f9b638a36cea5f15a720f467763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033f4f9b638a36cea5f15a720f467763">&#9670;&#160;</a></span>column_str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1_query.html#a3d0be57b8bd7f466bbece68da4223d92">string</a> mlib::Query::column_str </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return column value as an UTF-8 encoded string.  </p>
<p >If the column is <code>NULL</code>, the result is an empty string.  </p>

</div>
</div>
<a id="a43f70733482df265f72e270ddcd69929" name="a43f70733482df265f72e270ddcd69929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f70733482df265f72e270ddcd69929">&#9670;&#160;</a></span>column_str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1_query.html#a3d0be57b8bd7f466bbece68da4223d92">string</a> mlib::Query::column_str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return column value as an UTF-8 encoded string. </p>
<p >If the column is <code>NULL</code>, the result is an empty string. </p>

</div>
</div>
<a id="a0aab724208a7f837a6dd58f6ff397319" name="a0aab724208a7f837a6dd58f6ff397319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aab724208a7f837a6dd58f6ff397319">&#9670;&#160;</a></span>column_text() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * mlib::Query::column_text </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a NULL-terminated text with the column content.  </p>
<p >The memory for the string is freed automatically.</p>
<p >If the column value is <code>NULL</code> the result is a <code>NULL</code> pointer  </p>

</div>
</div>
<a id="a6dc1fbb9738f77c5e774ad2258d401c8" name="a6dc1fbb9738f77c5e774ad2258d401c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dc1fbb9738f77c5e774ad2258d401c8">&#9670;&#160;</a></span>column_text() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * mlib::Query::column_text </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a NULL-terminated text with the column content. </p>
<p >The memory for the string is freed automatically.</p>
<p >If the column value is <code>NULL</code> the result is a <code>NULL</code> pointer </p>

</div>
</div>
<a id="a78ea41e784736c198bb10f1c37bc9db5" name="a78ea41e784736c198bb10f1c37bc9db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ea41e784736c198bb10f1c37bc9db5">&#9670;&#160;</a></span>column_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SYSTEMTIME mlib::Query::column_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a SYSTEMTIME structure with the column content.  </p>

</div>
</div>
<a id="aeb4c7cb991e1237c042c1d2c0242efc6" name="aeb4c7cb991e1237c042c1d2c0242efc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4c7cb991e1237c042c1d2c0242efc6">&#9670;&#160;</a></span>column_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlib::Query::column_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return data type for a column specified by name or number.  </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SQLITE_INTEGER</td><td>64-bit signed integer </td></tr>
    <tr><td class="paramname">SQLITE_FLOAT</td><td>64-bit IEEE floating point </td></tr>
    <tr><td class="paramname">SQLITE_TEXT</td><td>string </td></tr>
    <tr><td class="paramname">SQLITE_BLOB</td><td>BLOB </td></tr>
    <tr><td class="paramname">SQLITE_NULL</td><td>NULL  </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a291400a7b75387cadc091b2796be9e4c" name="a291400a7b75387cadc091b2796be9e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291400a7b75387cadc091b2796be9e4c">&#9670;&#160;</a></span>column_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlib::Query::column_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return data type for a column specified by name or number. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SQLITE_INTEGER</td><td>64-bit signed integer </td></tr>
    <tr><td class="paramname">SQLITE_FLOAT</td><td>64-bit IEEE floating point </td></tr>
    <tr><td class="paramname">SQLITE_TEXT</td><td>string </td></tr>
    <tr><td class="paramname">SQLITE_BLOB</td><td>BLOB </td></tr>
    <tr><td class="paramname">SQLITE_NULL</td><td>NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9dff4f8a839df1c35bcf13b15f6c764" name="af9dff4f8a839df1c35bcf13b15f6c764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9dff4f8a839df1c35bcf13b15f6c764">&#9670;&#160;</a></span>database_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::database_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return originating schema name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colname</td><td>- column name</td></tr>
  </table>
  </dd>
</dl>
<p>If the query is a SELECT statement and <code>colname</code> is a table column (not an expression or subquery) the function returns the name of the schema where the column originated from. Otherwise the function returns an empty string.</p>
<p >The returned string is always UTF-8 encoded.</p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classmlib_1_1_database.html">Database</a> db (<span class="stringliteral">&quot;&quot;</span>);                         <span class="comment">// create temporary database</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE tbl(c1 TEXT)&quot;</span>);    <span class="comment">// schema</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;ATTACH \&quot;:memory:\&quot; AS db2&quot;</span>);</div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE db2.tbl2(c2 TEXT)&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classmlib_1_1_query.html">Query</a> q (db, <span class="stringliteral">&quot;SELECT c1, c2 FROM tbl JOIN tbl2&quot;</span>);  <span class="comment">// SELECT query</span></div>
<div class="line"><span class="keyword">auto</span> s = q.database_name (<span class="stringliteral">&quot;c1&quot;</span>);          <span class="comment">// s == &quot;main&quot;</span></div>
<div class="line">s = q.database_name (<span class="stringliteral">&quot;c2&quot;</span>);               <span class="comment">// s == &quot;db2&quot;</span></div>
<div class="ttc" id="aclassmlib_1_1_database_html"><div class="ttname"><a href="classmlib_1_1_database.html">mlib::Database</a></div><div class="ttdoc">Wrapper for database connection handle.</div><div class="ttdef"><b>Definition:</b> sqlitepp.h:25</div></div>
<div class="ttc" id="aclassmlib_1_1_query_html"><div class="ttname"><a href="classmlib_1_1_query.html">mlib::Query</a></div><div class="ttdoc">Wrapper for SQL prepared sentences.</div><div class="ttdef"><b>Definition:</b> sqlitepp.h:108</div></div>
</div><!-- fragment --><p >SQLITE must be compiled with the SQLITE_ENABLE_COLUMN_METADATA for this function to be available. </p>

</div>
</div>
<a id="af1804e036bf3cc4c5e97d8ad2e9ab341" name="af1804e036bf3cc4c5e97d8ad2e9ab341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1804e036bf3cc4c5e97d8ad2e9ab341">&#9670;&#160;</a></span>database_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::database_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return originating schema name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nc</td><td>- column number</td></tr>
  </table>
  </dd>
</dl>
<p>If the query is a SELECT statement and <code>nc</code> is a table column (not an expression or subquery) the function returns the name of the schema where the column originated from. Otherwise the function returns an empty string.</p>
<p >The returned string is always UTF-8 encoded.</p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classmlib_1_1_database.html">Database</a> db (<span class="stringliteral">&quot;&quot;</span>);                         <span class="comment">// create temporary database</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE tbl(c1 TEXT)&quot;</span>);    <span class="comment">// schema</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;ATTACH \&quot;:memory:\&quot; AS db2&quot;</span>);</div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE db2.tbl2(c2 TEXT)&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classmlib_1_1_query.html">Query</a> q (db, <span class="stringliteral">&quot;SELECT c1, c2 FROM tbl JOIN tbl2&quot;</span>);  <span class="comment">// SELECT query</span></div>
<div class="line"><span class="keyword">auto</span> s = q.database_name (0);             <span class="comment">// s == &quot;main&quot;</span></div>
<div class="line">s = q.database_name (1);                  <span class="comment">// s == &quot;db2&quot;</span></div>
</div><!-- fragment --><p >SQLITE must be compiled with the SQLITE_ENABLE_COLUMN_METADATA for this function to be available. </p>

</div>
</div>
<a id="a299ae3af338cf9a17795c04208db0331" name="a299ae3af338cf9a17795c04208db0331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299ae3af338cf9a17795c04208db0331">&#9670;&#160;</a></span>decl_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::decl_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colname</td><td>- column name If the query is a SELECT statement and <code>colname</code> is a table column (not an expression or subquery) the function returns the declared type of the table column. Otherwise the function returns an empty string.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned string is always UTF-8 encoded.</p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classmlib_1_1_database.html">Database</a> db(<span class="stringliteral">&quot;&quot;</span>);                          <span class="comment">// create temporary database</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE t1(c1 VARIANT)&quot;</span>);  <span class="comment">// schema</span></div>
<div class="line"><a class="code hl_class" href="classmlib_1_1_query.html">Query</a> q (db, <span class="stringliteral">&quot;SELECT c1 FROM t1&quot;</span>);        <span class="comment">// SELECT query</span></div>
<div class="line"><span class="keyword">auto</span> s = q.decl_type(<span class="stringliteral">&quot;c1&quot;</span>);               <span class="comment">// s == &quot;VARIANT&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a21197415531fe00458af8806f3839dd7" name="a21197415531fe00458af8806f3839dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21197415531fe00458af8806f3839dd7">&#9670;&#160;</a></span>decl_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::decl_type </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nc</td><td>- column number If the query is a SELECT statement and <code>nc</code> is a table column (not an expression or subquery) the function returns the declared type of the table column. Otherwise the function returns an empty string.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned string is always UTF-8 encoded.</p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classmlib_1_1_database.html">Database</a> db(<span class="stringliteral">&quot;&quot;</span>);                          <span class="comment">// create in-memory database</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE t1(c1 VARIANT)&quot;</span>);  <span class="comment">// schema</span></div>
<div class="line"><a class="code hl_class" href="classmlib_1_1_query.html">Query</a> q (db, <span class="stringliteral">&quot;SELECT c1 FROM t1&quot;</span>);        <span class="comment">// SELECT query</span></div>
<div class="line"><span class="keyword">auto</span> s = q.decl_type(0);                  <span class="comment">// s == &quot;VARIANT&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9d762cc2f632327002226ab537e8b7f2" name="a9d762cc2f632327002226ab537e8b7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d762cc2f632327002226ab537e8b7f2">&#9670;&#160;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlib::Query::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Statements are automatically finalized when <a class="el" href="classmlib_1_1_query.html" title="Wrapper for SQL prepared sentences.">Query</a> objects are destructed or assigned a new SQL text. </p>
<p >Occasionally user might need to manually finalize a query (for instance if he needs to close a database connection). </p>

</div>
</div>
<a id="a3d0be57b8bd7f466bbece68da4223d92" name="a3d0be57b8bd7f466bbece68da4223d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0be57b8bd7f466bbece68da4223d92">&#9670;&#160;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlib::Query::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve SQL text. </p>
<p >This is just syntactic sugar over <a class="el" href="classmlib_1_1_query.html#aec30b70916c6ccb20e730f791e4fa025" title="Retrieve SQL text.">Query::sql()</a> function. </p>

</div>
</div>
<a id="acb4ff3a27365317354c69b9fae0b6ea0" name="acb4ff3a27365317354c69b9fae0b6ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4ff3a27365317354c69b9fae0b6ea0">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1_query.html">Query</a> &amp; mlib::Query::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sql</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign SQL text to a query. </p>
<p >The object must have the database reference set before calling this function.</p>
<p >If a previous statement was attached to the object, it is finalized before the new statement is prepared. </p>

</div>
</div>
<a id="aec30b70916c6ccb20e730f791e4fa025" name="aec30b70916c6ccb20e730f791e4fa025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec30b70916c6ccb20e730f791e4fa025">&#9670;&#160;</a></span>sql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::sql </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve SQL text. </p>
<p >If the object is not connected with a prepared statement returns an empty string. </p>

</div>
</div>
<a id="ad2e176db273b9a8a26583b80d9db2cbd" name="ad2e176db273b9a8a26583b80d9db2cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e176db273b9a8a26583b80d9db2cbd">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlib_1_1erc.html">erc</a> mlib::Query::step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the statement. </p>
<p >When a new row of results is available the function returns SQLITE_ROW.</p>
<p >When there are no more result the function returns SQLITE_DONE. Both codes are wrapped in <a class="el" href="classmlib_1_1erc.html">erc</a> objects with priority level <code>ERROR_PRI_INFO</code> that normally don't throw an exception. Any other error is return at the normal priority level <code>ERROR_PRI_ERROR</code>. </p>

</div>
</div>
<a id="ae0aef20f35f72c99a6d0355bc2bf5dc5" name="ae0aef20f35f72c99a6d0355bc2bf5dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0aef20f35f72c99a6d0355bc2bf5dc5">&#9670;&#160;</a></span>table_name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::table_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>colname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return originating table name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colname</td><td>- column name If the query is a SELECT statement and <code>colname</code> is a table column (not an expression or subquery) the function returns the name of the table where the column originated from. Otherwise the function returns an empty string.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned string is always UTF-8 encoded.</p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classmlib_1_1_database.html">Database</a> db (<span class="stringliteral">&quot;&quot;</span>);                         <span class="comment">// create temporary database</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE tbl(c1 TEXT)&quot;</span>);    <span class="comment">// schema</span></div>
<div class="line"><a class="code hl_class" href="classmlib_1_1_query.html">Query</a> q (db, <span class="stringliteral">&quot;SELECT c1 FROM tbl&quot;</span>);       <span class="comment">// SELECT query</span></div>
<div class="line"><span class="keyword">auto</span> s = q.table_name (<span class="stringliteral">&quot;c1&quot;</span>);             <span class="comment">// s == &quot;tbl&quot;</span></div>
</div><!-- fragment --><p >SQLITE must be compiled with the SQLITE_ENABLE_COLUMN_METADATA for this function to be available. </p>

</div>
</div>
<a id="abce027452948e77237e51a40221730e5" name="abce027452948e77237e51a40221730e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce027452948e77237e51a40221730e5">&#9670;&#160;</a></span>table_name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlib::Query::table_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return originating table name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nc</td><td>- column number If the query is a SELECT statement and <code>nc</code> is a table column (not an expression or subquery) the function returns the name of the table where the column originated from. Otherwise the function returns an empty string.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned string is always UTF-8 encoded.</p>
<p >Example: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classmlib_1_1_database.html">Database</a> db (<span class="stringliteral">&quot;&quot;</span>);                         <span class="comment">// create temporary database</span></div>
<div class="line">db.exec (<span class="stringliteral">&quot;CREATE TABLE tbl(c1 TEXT)&quot;</span>);    <span class="comment">// schema</span></div>
<div class="line"><a class="code hl_class" href="classmlib_1_1_query.html">Query</a> q (db, <span class="stringliteral">&quot;SELECT c1 FROM tbl&quot;</span>);       <span class="comment">// SELECT query</span></div>
<div class="line"><span class="keyword">auto</span> s = q.table_name (0);                <span class="comment">// s == &quot;tbl&quot;</span></div>
</div><!-- fragment --><p >SQLITE must be compiled with the SQLITE_ENABLE_COLUMN_METADATA for this function to be available. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/development/mlib/include/mlib/<a class="el" href="sqlitepp_8h_source.html">sqlitepp.h</a></li>
<li>D:/development/mlib/src/<a class="el" href="sqlitepp_8cpp.html">sqlitepp.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
